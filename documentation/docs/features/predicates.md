---
tags: [Начало, Предикаты, Утверждения, Запросы, Мокирование]
sidebar_position: 4
---

# Предикаты

Предикаты это довольно мощный и универсальный инструмент. С помощью предикатов вы формируете набор условий, сродни отбору. Который можно использовать:

1. В утверждениях для [проверки коллекций](assertions/assertions-base.md#проверка-на-соответствие-набору-условий-предикату)
2. В утверждениях для [проверки записей базы](assertions/assertions-db)
3. Для [получения данных базы](queries.md)
4. Для указания условий при [обучении Мокито](mocking/mockito.md#параметры)

Предикаты расширяют и унифицируют функциональность тестового движка.  

Механизм предикатов ([ЮТест.Предикат](/api/ЮТест#предикат)):

* позволяет формировать наборы условий (отборы) и передавать их в качества параметров;
* построен по модели текучих выражения и имеет схожий с базовыми утверждениями синтаксис ([`ЮТест.ОжидаетЧто()`](/api/ЮТУтверждения));
* позволяет упростить и унифицировать многие механизмы движка, некоторые еще только в планах;
* а за счет этого, расширение функциональности предикатов автоматические расширяет функциональность многих механизмов движка.

Например, нам нужно проверить формирование записей в регистре.

```bsl
Процедура АктуализацияУведомлений() Экспорт
    
    // Тест удостовериться в отсутствии нужных записей перед вызовом метода
    // Вызовет метод формирующий записи в регистре
    // Проверит наличие сформированных записей
    // А также проверит записи на соответствие требований

    ИмяРегистра = "РегистрСведений.ОповещенияПользователя";
    Объект = ТестовыеДанные.Объект();
    
    // Для этого мы формируем отбор поиска записей
    Отбор = ЮТест.Предикат()
        .Реквизит("Источник").Равно(Объект)
        .Реквизит("ТипОповещения").Равно(Справочники.ТипыОповещенийПользователя.Уведомление)
        .Получить();
    
    // По этому отбору проверим отсутствие нужных записей
    ЮТест.ОжидаетЧтоТаблицаБазы(ИмяРегистра)
        .НеСодержитЗаписи(Отбор);
    
    УведомленияВызовСервера.АктуализацияУведомлений();
    
    // А после вызова метода - присутствие
    ЮТест.ОжидаетЧтоТаблицаБазы(ИмяРегистра)
        .СодержитЗаписи(Отбор);
    
    // Также получим сами записи используя тот же отбор
    ДанныеУведомления = ЮТЗапросы.Запись(ИмяРегистра, Отбор);
    
    ЮТест.ОжидаетЧто(ДанныеУведомления)
        .Свойство("Прочитано").ЭтоЛожь()
        .Свойство("Пользователь").Равно(Справочники.ГруппыОповещенийПользователей.Инженер);
    
КонецПроцедуры
```

## Примеры использования

* Проверка коллекции
  ```bsl
  ЮТест.ОжидаетЧто(Коллекция)
      .ЛюбойЭлементСоответствуетПредикату(ЮТест.Предикат()
          .Реквизит("Число").Равно(2)); // Проверят, что в коллекции есть элементы с реквизитом `Число`, которое равно `2`
  
  ЮТест.ОжидаетЧто(Коллекция)
      .Содержит(ЮТест.Предикат()
          .Реквизит("Число").Равно(2)); // Тоже самое, что и проверка выше

  ЮТест.ОжидаетЧто(Коллекция)
      .КаждыйЭлементСоответствуетПредикату(ЮТест.Предикат()
          .Заполнено().ИмеетТип("Массив")); // Проверят, что каждый элемент коллекции это заполненный массив
  
  ЮТест.ОжидаетЧто(Коллекция)
      .НеСодержит(ЮТест.Предикат()
          .Реквизит("Число").Равно(2)); // Проверят, что в коллекции нет элементов с реквизитом `Число`, которое равно `2`
  ```
* Описания параметров метода при мокировании  
    Например, имеем метод, который принимает в параметрах структуру. Необходимо вернуть 2 разных результата в зависимости от значения реквизита входной структуры.
    ```bsl
    Мокито.Обучение(Модуль)
        .Когда(Модуль.Посчитать(ЮТест.Предикат()
                .Реквизит("Оператор").Равно("Сложить")))
        .ВернутьРезультат(Результат1)

        .Когда(Модуль.Посчитать(ЮТест.Предикат()
                .Реквизит("Оператор").Равно("Вычесть")))
        .ВернутьРезультат(Результат2);
    ```
* Утверждения, проверяющие данные в базе на основании предикатов.
    ```bsl
    ЮТест.ОжидаетЧтоТаблица("Справочник.Товары").СодержитЗаписи(
        ЮТест.Предикат()
            .Реквизит("Наименование").Равно("Товар 1")
            .Реквизит("Ссылка").НеРавно(Исключение)
    );
    ```
* Получение записей из базы
    ```bsl
    ДанныеТовара = ЮТЗапросы.Запись("Справочник.Товары", ЮТест.Предикат()
            .Реквизит("Наименование").Равно("Товар 1")
            .Реквизит("Ссылка").НеРавно(Исключение));
    ```

## Особенности

### Особенности контекста

Предикаты как и большинство механизмов построены на текучих выражениях с сохранением состояния в глобальном контексте.

Это приводит к тому, что вы не можете сразу использовать несколько предикатов, например

```bsl
Мокито.Обучение(Модуль)
    .Когда(Модуль.СделатьЧтоТо(
        ЮТест.Предикат().ИмеетТип("Строка"),
        ЮТест.Предикат().ИмеетТип("Число")))
    .ВернутьРезультат(Результат1);
```

В этом примере 1С сначала вычислит выражения для всех параметров, а потом передаст их в метод и мы получим для обоих параметров один и тот же предикат, ожидающий тип `Число`.
Потому что состояние первого предиката будет заменено вторым. Для обхода этой проблемы можно использовать метод `Получить`, который возвращает текущее состояние.

```bsl
Мокито.Обучение(Модуль)
    .Когда(Модуль.СделатьЧтоТо(
        ЮТест.Предикат().ИмеетТип("Строка").Получить(),
        ЮТест.Предикат().ИмеетТип("Число")))
    .ВернутьРезультат(Результат1);
```

Такая же история при сохранение предикатов в переменные.

```bsl
ПроверкаСтрока = ЮТест.Предикат().ИмеетТип("Строка");
ПроверкаЧисло = ЮТест.Предикат().ИмеетТип("Число");
```

`ПроверкаСтрока` и `ПроверкаЧисло` будут равны и содержать одинаковые условия. Проблему также можно обойти используя метод `Получить`.

```bsl
ПроверкаСтрока = ЮТест.Предикат().ИмеетТип("Строка").Получить();
ПроверкаЧисло = ЮТест.Предикат().ИмеетТип("Число").Получить();
```

### Особенности реализации

Сам модуль предикатов используется только для формирования утверждений/условий.

Реализацией проверок и формированием условий занимаются другие модули и возможна ситуация, когда некоторые предикаты еще не реализованы или не поддерживаются каким-либо механизмом. Например, проверка заполненности не поддерживается запросами.
